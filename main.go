package main

import (
	"bufio"
	"bytes"
	"crypto/sha256"
	_ "embed"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/go-faster/errors"
)

// DisableSwap disables swap on node.
func DisableSwap() error {
	{
		// Update /etc/fstab.
		fileName := "/etc/fstab"
		data, err := os.ReadFile(fileName)
		if err != nil {
			return errors.Wrap(err, "read")
		}
		// Replace line with / swap to # Swap disabled.
		scanner := bufio.NewScanner(bytes.NewReader(data))
		targetString := []byte(" swap ")
		if !bytes.Contains(data, targetString) {
			fmt.Println("> Swap is not enabled")
			return nil
		}
		fmt.Println("> Updating /etc/fstab")
		var out []byte
		for scanner.Scan() {
			line := scanner.Text()
			if len(line) > 0 && bytes.Contains(scanner.Bytes(), targetString) {
				out = append(out, '#')
			}
			out = append(out, line...)
			out = append(out, '\n')
		}
		// Write back.
		if err := os.WriteFile("/etc/fstab", out, 0644); err != nil {
			return errors.Wrap(err, "write")
		}
	}
	{
		// Disable swap.
		fmt.Println("> Disabling swap")
		cmd := exec.Command("swapoff", "-a")
		if err := cmd.Run(); err != nil {
			return errors.Wrap(err, "run")
		}
	}
	return nil
}

func appendEnv(vars []string, key, value string) []string {
	return append(vars, key+"="+value)
}

func APTUpdate() error {
	fmt.Println("> apt-get update")
	cmd := exec.Command("apt-get", "update")
	cmd.Env = appendDebianFrontend(os.Environ())
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		return errors.Wrap(err, "apt update")
	}
	return nil
}

func appendDebianFrontend(vars []string) []string {
	return appendEnv(vars, "DEBIAN_FRONTEND", "noninteractive")
}

func APTUpgrade() error {
	fmt.Println("> apt-get upgrade")
	cmd := exec.Command("apt-get", "upgrade", "-y")
	cmd.Env = appendDebianFrontend(os.Environ())
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		return errors.Wrap(err, "apt upgrade")
	}
	return nil
}

func APTInstall(packages ...string) error {
	fmt.Println("> apt-get install", packages)
	cmd := exec.Command("apt-get", append([]string{"install", "-y"}, packages...)...)
	cmd.Env = appendDebianFrontend(os.Environ())
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		return errors.Wrap(err, "apt install")
	}
	return nil
}

func APTHold(packages ...string) error {
	fmt.Println("> apt-mark hold", packages)
	cmd := exec.Command("apt-mark", append([]string{"hold"}, packages...)...)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		return errors.Wrap(err, "apt-mark hold")
	}
	return nil
}

func APTKey(keyName, keyURL string) error {
	fmt.Printf("> Adding GPG key %s\n", keyName)
	dirName := "/etc/apt/keyrings"
	if _, err := os.Stat(dirName); os.IsNotExist(err) {
		fmt.Println("> Creating", dirName)
		if err := os.Mkdir(dirName, 0755); err != nil {
			return errors.Wrap(err, "mkdir")
		}
	}
	fileName := filepath.Join(dirName, keyName+".gpg")
	if _, err := os.Stat(fileName); err == nil {
		fmt.Printf("> GPG key %s already exists\n", fileName)
		return nil
	}
	fmt.Println("Downloading key", keyURL)
	res, err := http.Get(keyURL)
	if err != nil {
		return errors.Wrap(err, "get key")
	}
	defer func() {
		_ = res.Body.Close()
	}()
	if res.StatusCode != http.StatusOK {
		return errors.Errorf("bad status: %s", res.Status)
	}
	data, err := io.ReadAll(res.Body)
	if err != nil {
		return errors.Wrap(err, "read key")
	}
	fmt.Printf("> Writing %s\n", fileName)
	cmd := exec.Command("gpg", "--dearmour", "-o", fileName)
	cmd.Stdin = bytes.NewReader(data)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		return errors.Wrap(err, "gpg")
	}
	return nil
}

type APTAddRepoOptions struct {
	Name       string
	Arch       []string
	SignedBy   string
	URL        string
	Components []string
}

func APTAddRepo(opt APTAddRepoOptions) error {
	// sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
	// deb [arch=amd64,arm64,armhf] https://packages.microsoft.com/repos/code stable main
	// deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.32/deb/ /
	// deb [arch=amd64 signed-by=/usr/share/keyrings/some-repo.gpg] http://some.repo/apt dev main
	var s strings.Builder
	s.WriteString("# Generated by ki\n")
	s.WriteString("deb ")
	var components []string
	if len(opt.Arch) > 0 {
		components = append(components, "arch="+strings.Join(opt.Arch, ","))
	}
	if opt.SignedBy != "" {
		components = append(components, "signed-by="+opt.SignedBy)
	}
	if len(components) > 0 {
		s.WriteString("[")
		s.WriteString(strings.Join(components, " "))
		s.WriteString("] ")
	}
	s.WriteString(opt.URL)
	if len(opt.Components) > 0 {
		s.WriteString(" ")
		s.WriteString(strings.Join(opt.Components, " "))
	}
	s.WriteString("\n")

	// Write to file.
	fileName := filepath.Join("/etc/apt/sources.list.d/", opt.Name+".list")
	fmt.Printf("> Writing %s\n", fileName)
	if err := os.WriteFile(fileName, []byte(s.String()), 0644); err != nil {
		return errors.Wrap(err, "write")
	}

	return nil
}

func lsbRelease() (string, error) {
	cmd := exec.Command("lsb_release", "-cs")
	out, err := cmd.Output()
	if err != nil {
		return "", errors.Wrap(err, "lsb_release")
	}
	return string(bytes.TrimSpace(out)), nil
}

func CheckTCPPortIsFree(n int) error {
	// nc 127.0.0.1 6443 -v
	// ^ should fail, but in go.
	fmt.Printf("> Checking port %d\n", n)
	tcpAddr := &net.TCPAddr{IP: net.ParseIP("127.0.0.1"), Port: n}
	conn, err := net.DialTCP("tcp", nil, tcpAddr)
	if err != nil {
		fmt.Printf("> Port %d is free\n", n)
		return nil
	}
	_ = conn.Close()
	return errors.Errorf("port %d is in use", n)
}

func LoadKernelModules(name string, modules ...string) error {
	for _, module := range modules {
		fmt.Println("> Loading module", module)
		cmd := exec.Command("modprobe", module)
		cmd.Stderr = os.Stderr
		cmd.Stdout = os.Stdout
		if err := cmd.Run(); err != nil {
			return errors.Wrapf(err, "modprobe %s", module)
		}
	}
	// Persist in named configuration.
	fileName := filepath.Join("/etc/modules-load.d/", name+".conf")
	fmt.Printf("> Writing %s\n", fileName)
	var out []byte
	for _, module := range modules {
		out = append(out, module...)
		out = append(out, '\n')
	}
	if err := os.WriteFile(fileName, out, 0644); err != nil {
		return errors.Wrap(err, "write")
	}
	return nil
}

func ConfigureKernelParameters(name string, params map[string]any) error {
	fmt.Printf("> Configuring kernel parameters for %s\n", name)
	fileName := filepath.Join("/etc/sysctl.d/", name+".conf")
	keys := make([]string, 0, len(params))
	for key := range params {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	fmt.Printf("> Writing %s\n", fileName)
	var out []byte
	for _, key := range keys {
		out = append(out, key...)
		out = append(out, '=')
		out = append(out, fmt.Sprintf("%v", params[key])...)
		out = append(out, '\n')
	}
	if err := os.WriteFile(fileName, out, 0644); err != nil {
		return errors.Wrap(err, "write")
	}
	// Reload.
	cmd := exec.Command("sysctl", "--system")
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		return errors.Wrap(err, "sysctl --system")
	}
	return nil
}

func Systemctl(action, service string) error {
	fmt.Printf("> systemctl %s %s\n", action, service)
	cmd := exec.Command("systemctl", action, service)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		return errors.Wrap(err, "systemctl")
	}
	return nil
}

type KubeadmInitOptions struct {
	SkipPhases           []string
	PodNetworkCIDR       string
	ServiceCIDR          string
	ControlPlaneEndpoint string
}

func KubeadmInit(opts KubeadmInitOptions) error {
	var args []string
	if len(opts.SkipPhases) > 0 {
		args = append(args, "--skip-phases="+strings.Join(opts.SkipPhases, ","))
	}
	if opts.PodNetworkCIDR != "" {
		args = append(args, "--pod-network-cidr="+opts.PodNetworkCIDR)
	}
	if opts.ServiceCIDR != "" {
		args = append(args, "--service-cidr="+opts.ServiceCIDR)
	}
	if opts.ControlPlaneEndpoint != "" {
		args = append(args, "--control-plane-endpoint="+opts.ControlPlaneEndpoint)
	}
	fmt.Println("> kubeadm init", args)
	cmd := exec.Command("kubeadm", append([]string{"init"}, args...)...)
	output := bytes.NewBuffer(nil)
	cmd.Stderr = io.MultiWriter(os.Stderr, output)
	cmd.Stdout = io.MultiWriter(os.Stdout, output)
	if err := cmd.Run(); err != nil {
		return errors.Wrap(err, "kubeadm init")
	}
	reToken := regexp.MustCompile(`--token (\S+)`)
	reHash := regexp.MustCompile(`--discovery-token-ca-cert-hash (\S+)`)
	var token, hash string
	scanner := bufio.NewScanner(output)
	for scanner.Scan() {
		line := scanner.Text()
		if m := reToken.FindStringSubmatch(line); m != nil {
			token = m[1]
		}
		if m := reHash.FindStringSubmatch(line); m != nil {
			hash = m[1]
		}
	}
	if token == "" || hash == "" {
		return errors.New("token or hash not found")
	}
	fmt.Printf("> Token: %s\nHash: %s\n", token, hash)
	return nil
}

//go:embed cilium.yml.tmpl
var ciliumConfigTemplate string

type CiliumConfig struct {
	K8sServiceHost string // 1.1.1.1
}

type CiliumInstallOptions struct {
	Version        string
	K8sServiceHost string
}

func CiliumInstall(opt CiliumInstallOptions) error {
	// Should be installed via helm.
	// helm upgrade --version 1.13.2 --install --create-namespace --namespace "cilium" cilium cilium/cilium --values cilium.yml
	// 1. Render template.
	tmpl, err := template.New("cilium.yml").Parse(ciliumConfigTemplate)
	if err != nil {
		return errors.Wrap(err, "parse template")
	}
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, CiliumConfig{
		K8sServiceHost: opt.K8sServiceHost,
	}); err != nil {
		return errors.Wrap(err, "execute template")
	}

	// Write to file.
	fileName := "cilium.yml"
	fmt.Printf("> Writing %s\n", fileName)
	if err := os.WriteFile(fileName, buf.Bytes(), 0644); err != nil {
		return errors.Wrap(err, "write")
	}

	args := []string{
		"upgrade",
		"--install",
		"--create-namespace",
		"--namespace", "cilium",
		"cillium",
		"cillium/cillium",
		"--values", fileName,
	}
	if opt.Version != "" {
		args = append(args, "--version", opt.Version)
	}
	fmt.Println("> helm upgrade", args)
	cmd := exec.Command("helm", args...)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	cmd.Env = appendEnv(os.Environ(), "KUBECONFIG", "/etc/kubernetes/admin.conf")
	if err := cmd.Run(); err != nil {
		return errors.Wrap(err, "helm upgrade")
	}
	return nil
}

func ConfigureContainerd() error {
	// 1. Get default config.
	cmd := exec.Command("containerd", "config", "default")
	out, err := cmd.Output()
	if err != nil {
		return errors.Wrap(err, "containerd config default")
	}
	// 2. Update config.
	// sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/g' /etc/containerd/config.toml
	out = bytes.ReplaceAll(out, []byte("SystemdCgroup = false"), []byte("SystemdCgroup = true"))
	// Write back.
	fileName := "/etc/containerd/config.toml"
	fmt.Printf("> Writing %s\n", fileName)
	if err := os.WriteFile(fileName, out, 0644); err != nil {
		return errors.Wrap(err, "write")
	}
	// 3. Restart containerd.
	if err := Systemctl("restart", "containerd"); err != nil {
		return errors.Wrap(err, "restart containerd")
	}
	// 4. Enable containerd.
	if err := Systemctl("enable", "containerd"); err != nil {
		return errors.Wrap(err, "enable containerd")
	}
	fmt.Println("> Configured, restarted and enabled containerd")
	return nil
}

type Binary struct {
	URL    string
	Name   string
	SHA256 string
}

// InstallBinary installs a binary to machine.
func InstallBinary(bin Binary) error {
	fmt.Println("> Install binary", bin.Name)
	targetBinaryPath := "/usr/local/bin/" + bin.Name
	if _, err := os.Stat(targetBinaryPath); err == nil {
		fmt.Println("> Binary already exists")
		return nil
	}
	// 1. Download to tmp.
	baseName := filepath.Base(bin.URL)
	workDir, err := os.MkdirTemp("", "ki-dl-")
	defer func() {
		_ = os.RemoveAll(workDir)
	}()
	targetName := filepath.Join(workDir, baseName)
	if err != nil {
		return errors.Wrap(err, "create temp")
	}
	{
		f, err := os.Create(targetName)
		if err != nil {
			return errors.Wrap(err, "create temp")
		}
		defer func() {
			_ = f.Close()
			_ = os.Remove(f.Name())
		}()
		fmt.Println("> Downloading", bin.URL)
		res, err := http.Get(bin.URL)
		if err != nil {
			return errors.Wrap(err, "get")
		}
		defer func() {
			_ = res.Body.Close()
		}()
		if res.StatusCode != http.StatusOK {
			return errors.Errorf("bad status: %s", res.Status)
		}
		if _, err := io.Copy(f, res.Body); err != nil {
			return errors.Wrap(err, "copy")
		}
		if err := f.Close(); err != nil {
			return errors.Wrap(err, "close")
		}
	}
	var binaryPath string
	{
		// Unpack.
		fmt.Println("> Unpacking")
		cmd := exec.Command("tar", "-xzf", baseName)
		cmd.Stderr = os.Stderr
		cmd.Stdout = os.Stdout
		cmd.Dir = workDir
		if err := cmd.Run(); err != nil {
			return errors.Wrap(err, "tar")
		}
		// Now find a binary in directory, recursively.
		err := filepath.Walk(workDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			if info.IsDir() {
				return nil
			}
			if info.Name() == bin.Name {
				binaryPath = path
				return io.EOF
			}
			return nil
		})
		if err != nil && !errors.Is(err, io.EOF) {
			return errors.Wrap(err, "walk")
		}
		if binaryPath == "" {
			return errors.New("binary not found")
		}
	}
	{
		// 2. Check SHA256.
		fmt.Println("> Checking SHA256")
		h := sha256.New()
		f, err := os.Open(targetName)
		if err != nil {
			return errors.Wrap(err, "open")
		}
		defer func() {
			_ = f.Close()
		}()
		if _, err := io.Copy(h, f); err != nil {
			return errors.Wrap(err, "copy")
		}
		if got := fmt.Sprintf("%x", h.Sum(nil)); got != bin.SHA256 {
			return errors.Errorf("bad sha256: %s", got)
		}
		fmt.Println("> SHA256 OK")
	}
	// Install with chmod +x
	cmd := exec.Command("install", "-m", "0755", binaryPath, targetBinaryPath)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		return errors.Wrap(err, "install")
	}
	return nil
}

type Route struct {
	Dst      string   `json:"dst"`
	Gateway  string   `json:"gateway,omitempty"`
	Dev      string   `json:"dev"`
	Protocol string   `json:"protocol"`
	PrefSrc  string   `json:"prefsrc"`
	Metric   int      `json:"metric"`
	Flags    []any    `json:"flags"`
	Metrics  []Metric `json:"metrics,omitempty"`
	Scope    string   `json:"scope,omitempty"`
}

type Metric struct {
	MTU int `json:"mtu"`
}

func GetDefaultGatewayIP() (string, error) {
	// This is valid for hetzher.
	cmd := exec.Command("ip", "-j", "route", "show", "default")
	out, err := cmd.Output()
	if err != nil {
		return "", errors.Wrap(err, "ip route show default")
	}
	var routes []Route
	if err := json.Unmarshal(out, &routes); err != nil {
		return "", errors.Wrap(err, "unmarshal")
	}
	for _, route := range routes {
		if route.Dst == "default" {
			return route.PrefSrc, nil
		}
	}
	return "", errors.New("default gateway not found")
}

func run() error {
	var arg struct {
		Version string

		CiliumVersion string

		CiliumCliVersion string
		CiliumCliSHA256  string

		HelmVersion string
		HelmSHA256  string
	}
	flag.StringVar(&arg.Version, "version", "v1.31", "kubernetes version")
	flag.StringVar(&arg.HelmVersion, "helm-version", "v3.17.0", "helm version")
	flag.StringVar(&arg.HelmSHA256, "helm-sha256", "fb5d12662fde6eeff36ac4ccacbf3abed96b0ee2de07afdde4edb14e613aee24", "helm sha256")
	flag.StringVar(&arg.CiliumVersion, "cilium-version", "1.17.0", "cilium version")
	flag.StringVar(&arg.CiliumCliVersion, "cilium-cli-version", "v0.16.24", "cilium cli version")
	flag.StringVar(&arg.CiliumCliSHA256, "cilium-cli-sha256", "019c9c765222b3db5786f7b3a0bff2cd62944a8ce32681acfb47808330f405a7", "cilium cli sha256")
	flag.Parse()

	// 0. Check OS.
	release, err := lsbRelease()
	if err != nil {
		return errors.Wrap(err, "lsb_release")
	}
	fmt.Println("> OS release:", release)
	supported := map[string]struct{}{
		"noble": {},
	}
	if _, ok := supported[release]; !ok {
		return errors.Errorf("unsupported OS: %s", release)
	}
	defaultGateway, err := GetDefaultGatewayIP()
	if err != nil {
		return errors.Wrap(err, "get default gateway")
	}
	fmt.Println("> Default gateway:", defaultGateway)
	// Check required ports
	if err := CheckTCPPortIsFree(6443); err != nil {
		return errors.Wrap(err, "check k8s port")
	}
	if err := InstallBinary(Binary{
		Name:   "helm",
		URL:    "https://get.helm.sh/helm-" + arg.HelmVersion + "-linux-amd64.tar.gz",
		SHA256: arg.HelmSHA256,
	}); err != nil {
		return errors.Wrap(err, "install helm")
	}

	// https://github.com/cilium/cilium-cli/releases/
	if err := InstallBinary(Binary{
		Name:   "cilium",
		URL:    "https://github.com/cilium/cilium-cli/releases/download/" + arg.CiliumCliVersion + "/cilium-linux-amd64.tar.gz",
		SHA256: arg.CiliumCliSHA256,
	}); err != nil {
		return errors.Wrap(err, "install cilium")
	}

	// Swap configuration
	if err := DisableSwap(); err != nil {
		return errors.Wrap(err, "disable swap")
	}
	//  Update apt cache
	if err := APTUpdate(); err != nil {
		return errors.Wrap(err, "apt update")
	}
	//  Upgrade packages
	if err := APTUpgrade(); err != nil {
		return errors.Wrap(err, "apt upgrade")
	}
	// Installing a container runtime.
	if err := LoadKernelModules("containerd", "overlay", "br_netfilter"); err != nil {
		return errors.Wrap(err, "load kernel modules")
	}
	if err := ConfigureKernelParameters("kubernetes", map[string]any{
		"net.bridge.bridge-nf-call-ip6tables": 1,
		"net.bridge.bridge-nf-call-iptables":  1,
		"net.ipv4.ip_forward":                 1,
	}); err != nil {
		return errors.Wrap(err, "configure kernel parameters")
	}
	fmt.Println("> Installing containerd")
	if err := APTInstall("curl", "gnupg2", "software-properties-common", "apt-transport-https", "ca-certificates"); err != nil {
		return errors.Wrap(err, "install containerd dependencies")
	}
	if err := APTKey("docker", "https://download.docker.com/linux/ubuntu/gpg"); err != nil {
		return errors.Wrap(err, "add docker key")
	}
	if err := APTAddRepo(APTAddRepoOptions{
		Name:       "docker",
		URL:        "https://download.docker.com/linux/ubuntu",
		SignedBy:   "/etc/apt/trusted.gpg.d/docker.gpg",
		Arch:       []string{"amd64"},
		Components: []string{release, "stable"},
	}); err != nil {
		return errors.Wrap(err, "add docker repo")
	}
	if err := APTUpdate(); err != nil {
		return errors.Wrap(err, "apt update")
	}
	if err := APTInstall("curl", "containerd.io"); err != nil {
		return errors.Wrap(err, "install containerd")
	}
	if err := ConfigureContainerd(); err != nil {
		return errors.Wrap(err, "configure containerd")
	}
	// Install k8s
	fmt.Println("> Installing k8s")
	if err := APTKey("k8s", "https://pkgs.k8s.io/core:/stable:/"+arg.Version+"/deb/Release.key"); err != nil {
		return errors.Wrap(err, "add k8s key")
	}
	if err := APTAddRepo(APTAddRepoOptions{
		Name:       "k8s",
		URL:        "https://pkgs.k8s.io/core:/stable:/" + arg.Version + "/deb/",
		SignedBy:   "/etc/apt/keyrings/k8s.gpg",
		Components: []string{"/"},
	}); err != nil {
		return errors.Wrap(err, "add k8s repo")
	}
	if err := APTUpdate(); err != nil {
		return errors.Wrap(err, "apt update")
	}
	if err := APTInstall("kubeadm", "kubelet", "kubectl"); err != nil {
		return errors.Wrap(err, "install k8s")
	}
	if err := APTHold("kubeadm", "kubelet", "kubectl"); err != nil {
		return errors.Wrap(err, "hold k8s")
	}
	// 6. Enable and start kubelet
	fmt.Println("> Starting kubelet")
	if err := Systemctl("enable", "kubelet"); err != nil {
		return errors.Wrap(err, "enable kubelet")
	}
	if err := Systemctl("start", "kubelet"); err != nil {
		return errors.Wrap(err, "start kubelet")
	}
	// 7. Initialize k8s
	fmt.Println("> Initializing k8s")
	if err := KubeadmInit(KubeadmInitOptions{
		SkipPhases:           []string{"addon/kube-proxy"},
		PodNetworkCIDR:       "10.244.0.0/16",
		ServiceCIDR:          "10.96.0.0/16",
		ControlPlaneEndpoint: defaultGateway,
	}); err != nil {
		return errors.Wrap(err, "kubeadm init")
	}
	if err := CiliumInstall(CiliumInstallOptions{
		Version:        arg.CiliumVersion,
		K8sServiceHost: defaultGateway,
	}); err != nil {
		return errors.Wrap(err, "cilium install")
	}

	return nil
}

func main() {
	if err := run(); err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "Error: %+v\n", err)
		os.Exit(1)
	}
}
